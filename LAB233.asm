org 0
	acall	CONFIGURE_LCD
CLR 42H


	 MOV 40H, #58H
	MOV 41H, #96H
	
MOV R4, #5
VERYSTART:MOV R3, #8
START:	MOV A, 41H
	ANL A, #01H
	ORL 42H, A ;16TH BIT
	MOV R0,A
	MOV A, 41H
	ANL A, #04H
	RR A
	RR A
	XRL A, R0
	
	MOV R0, A
	MOV A, 41H
	ANL A, #08H
	RR A
	RR A
	RR A
	XRL A, R0
	
	MOV R0,A
	MOV A, 41H
	ANL A, #20H
	RL A
	RL A
	RL A
	XRL A, R0
	RR A
	MOV R0, A
	
	CLR CY
	MOV A, 40H
	RRC A
	MOV 40H, A ;WITHOUT THE XORED BITS 
	MOV A, 41H
	RR A
	MOV ACC.7, C 
	MOV 41H, A
	
	MOV A, R0
	MOV C, ACC.7
	MOV A,40H
	MOV ACC.7, C
	MOV 40H, A
		
	MOV A, 42H
	RR A
	MOV 42H,A 
	
	
	DJNZ R3, START
	MOV A, 42H
	ACALL HEXTOASCII
	
	aCALL DELAY2
	mov a,#01H	;CLEAR DISPLAY SCREEN
	acall SEND_COMMAND
	CLR A
	MOV 42H, A
	DJNZ R4, VERYSTART
	LJMP ENDDDD

COUNT EQU 19453
DELAY2: MOV R5, #20
DELAY3:MOV TMOD,#01H
	MOV TH0, #HIGH COUNT
	MOV TL0, #LOW COUNT
	SETB TR0
AGAIN:	JNB TF0, AGAIN
	CLR TR0
	CLR TF0
	DJNZ R5, DELAY3

	RET
HEXTOASCII:
		
	MOV B, #100 ;GET THE DIGITS	
	DIV AB
	MOV R0, A
	CJNE A, #0, GIT1
	LJMP GIT2
	
GIT1:	ADD A, #30H
	ACALL SEND_DATA	
	MOV A,#06H
	ACALL SEND_COMMAND
	
GIT2:	MOV A,B
	MOV B,#10
	DIV AB
	MOV R1, A
	CJNE A, #0, GIT3
	SJMP GIT4
GIT3:	ADD A, #30H
	ACALL SEND_DATA
	MOV A,#06H
	ACALL SEND_COMMAND
	MOV A,B
	ADD A, #30H
	ACALL SEND_DATA
	
	SJMP ENDDD
GIT4:	CJNE R0, #0,GIT5
	
	MOV A,B
	ADD A, #30H
	ACALL SEND_DATA

	SJMP ENDDD
GIT5: 	CJNE R1, #0, GIT6
	MOV A, #30H
	ACALL SEND_DATA
	MOV A,B
	ADD A, #30H
	ACALL SEND_DATA
	
	SJMP ENDDD
GIT6:   MOV A, B
	ADD A, #30H
	ACALL SEND_DATA
	
ENDDD:	RET
	

ENDDDD: SJMP ENDDDD


CONFIGURE_LCD:	;THIS SUBROUTINE SENDS THE INITIALIZATION COMMANDS TO THE LCD
	mov a,#38H	;TWO LINES, 5X7 MATRIX
	acall SEND_COMMAND
	mov a,#0FH	;DISPLAY ON, CURSOR BLINKING
	acall SEND_COMMAND
	mov a,#06H	;INCREMENT CURSOR (SHIFT CURSOR TO RIGHT)
	acall SEND_COMMAND
	mov a,#01H	;CLEAR DISPLAY SCREEN
	acall SEND_COMMAND
	mov a,#80H	;FORCE CURSOR TO BEGINNING OF THE FIRST LINE
	acall SEND_COMMAND
	ret



SEND_COMMAND:
	mov p1,a		;THE COMMAND IS STORED IN A, SEND IT TO LCD
	clr p3.5		;RS=0 BEFORE SENDING COMMAND
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret


SEND_DATA:
	mov p1,a		;SEND THE DATA STORED IN A TO LCD
	setb p3.5	;RS=1 BEFORE SENDING DATA
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret


DELAY:
	push 0
	push 1
	mov r0,#50
DELAY_OUTER_LOOP:
	mov r1,#255
	djnz r1,$
	djnz r0,DELAY_OUTER_LOOP
	pop 1
	pop 0
	ret


KEYBOARD: ;takes the key pressed from the keyboard and puts it to A
	mov	P0, #0ffh	;makes P0 input
K1:
	mov	P2, #0	;ground all rows
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, K1
K2:
	acall	DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER
	sjmp	K2
KB_OVER:
	acall DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER1
	sjmp	K2
KB_OVER1:
	mov	P2, #11111110B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_0
	mov	P2, #11111101B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_1
	mov	P2, #11111011B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_2
	mov	P2, #11110111B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_3
	ljmp	K2
	
ROW_0:
	mov	DPTR, #KCODE0
	sjmp	KB_FIND
ROW_1:
	mov	DPTR, #KCODE1
	sjmp	KB_FIND
ROW_2:
	mov	DPTR, #KCODE2
	sjmp	KB_FIND
ROW_3:
	mov	DPTR, #KCODE3
KB_FIND:
	rrc	A
	jnc	KB_MATCH
	inc	DPTR
	sjmp	KB_FIND
KB_MATCH:
	clr	A
	movc	A, @A+DPTR; get ASCII code from the table 
	ret

;ASCII look-up table 
KCODE0:	DB	'1', '2', '3', 'A'
KCODE1:	DB	'4', '5', '6', 'B'
KCODE2:	DB	'7', '8', '9', 'C'
KCODE3:	DB	'*', '0', '#', 'D'

END


